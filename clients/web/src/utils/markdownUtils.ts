import markdownit, { Token } from "markdown-it";
import anchor from "markdown-it-anchor";
import json5 from "json5";
import {
  Action,
  Section,
  Choice,
  Condition,
  Image,
  Navigation,
  Paragraph,
  Part,
  Settings,
  Story,
  State,
} from "../types";

// default mode
const md = markdownit({
  linkify: true,
}).use(anchor);

const mermaidComment = "<!-- This chart is autogenerated -->";

type CodeData = { active: boolean; parts: Part[]; token?: Token };

function parseImage(token: Token): Image | undefined {
  const image = token.children?.find((token) => token.type === "image");
  if (image) {
    const description = token.children
      ?.find((token) => token.type === "text")
      ?.content.replace(/<!---/, "")
      .replace(/-->/, "")
      .trim();
    const url = image.attrs?.find(([key]) => key === "src")?.[1];
    return {
      type: "image",
      text: image.content,
      description: description,
      url,
    };
  }
}

function parseNavigation(code: Token): Part | undefined {
  const navigationMatch = code.content.match(/^->\s?\[([^\]]*)\]\(([^)]*)\)/);
  if (navigationMatch) {
    return {
      type: "navigation",
      text: navigationMatch[1],
      target: navigationMatch[2],
    };
  }
}

function parseActionPart(content: string): Action {
  const noErrorMessages = content.replace(/\nJSON5:.*/g, "");
  try {
    const state = json5.parse(noErrorMessages);
    return {
      type: "action",
      state,
    };
  } catch (e) {
    const error = e instanceof Error ? e : new Error("unknown error");
    return {
      type: "action",
      markdown: noErrorMessages,
      state: {},
      error: error.message,
    };
  }
}

function parseCode(codeData: CodeData): Condition {
  let error: string | undefined;

  const condition = codeData.token?.children
    ?.at(0)
    ?.content.replace(/\s*\{\s*?$/, "");

  if (!condition) {
    error = "Could not parse condition";
  }
  const childrenParts = [];
  for (const children of codeData.token?.children ?? []) {
    switch (children.type) {
      case "text": {
        const part: Paragraph = { type: "paragraph", text: children.content };
        childrenParts.push(part);
        break;
      }
    }
  }

  const allParts = [...childrenParts, ...codeData.parts];

  if (allParts.length === 0) {
    error = "No parts found in code block";
  }

  return {
    type: "condition",
    condition: condition ?? "",
    true: allParts,
    ...(error ? { error, markdown: codeData.token?.content } : {}),
  };
}

export function parseMarkdown(markdown: string): Story {
  const tokens = md.parse(markdown, {});

  console.log("tokens", tokens);

  const sections: Array<Section> = [];
  let section: Section = { parts: [] };
  let inHeading: string | undefined;
  let inChapterIntro = false;
  let storyName = "";
  let settings: Action<Settings & State> = { type: "action", state: {} };
  let storyDescription: string | undefined;

  const inCode: { active: boolean; parts: Part[]; token?: Token } = {
    active: false,
    parts: [],
  };

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    let part: Part | undefined;

    if (!token) continue;

    if (token.type === "heading_open") {
      inHeading = token.tag;
      inChapterIntro = token.tag === "h1";
      section = { parts: [] };
    }
    if (token.type === "heading_close") {
      inHeading = undefined;
      if (!inChapterIntro) {
        sections.push(section);
      }
    }
    if (token.type === "inline") {
      const image = token.children?.find((token) => token.type === "image");
      const link = token.children?.find((token) => token.type === "link_open");
      const code = token.children?.find(
        (token) => token.type === "code_inline"
      );

      if (code) {
        const navigation = parseNavigation(code);
        if (navigation) {
          part = navigation;
        } else {
          const isStart = token.children?.at(0)?.content.endsWith("{");
          const isEnd = token.children?.at(-1)?.content.endsWith("}");
          if (isStart) {
            inCode.active = true;
            inCode.parts = [];
            inCode.token = token;
          }
          if (isEnd) {
            inCode.active = false;
            part = parseCode(inCode);
          }
        }
      } else if (image) {
        part = parseImage(token);
      } else if (link && token.children) {
        const text = token.children
          .filter((token) => token.type === "text")
          .map((token) => token.content)
          .join("");
        const linkOpenIndex =
          token.children.findIndex((token) => token.type === "link_open") ?? 0;
        const key = token.children[linkOpenIndex + 1]?.content.toLowerCase();
        const target = link.attrs
          ?.find(([key]) => key === "href")?.[1]
          ?.replace("", "");
        if (text && target) {
          part = {
            type: "choice",
            text,
            target,
            key,
            markdown: token.content,
          };
        }
      } else {
        if (inHeading) {
          if (inChapterIntro) {
            storyName = token.content;
          }
          const heading = token.content.replace(/<!---.*-->/, "").trim();
          section.heading = heading;
          section.id = encodeURIComponent(
            heading.toLowerCase().replace(/ /g, "-")
          );
          if (inHeading === "h2") {
            console.log("section", section, inHeading);
            part = {
              type: "header",
              text: heading,
            };
          }
        } else {
          if (token.content.startsWith("<!--")) {
            if (token.content !== mermaidComment && !inHeading) {
              part = {
                type: "comment",
                text: token.content
                  .replace(/^<!-{1,3}/, "")
                  .replace(/-->$/, "")
                  .trim(),
              };
            }
          } else {
            if (inChapterIntro) {
              storyDescription = `${storyDescription ?? ""}${
                token.content
              }\n\n`;
            } else {
              part = {
                type: "paragraph",
                text: token.content,
              };
            }
          }
        }
      }
    }
    if (token.type === "fence" && token.info !== "mermaid") {
      part = parseActionPart(token.content);
      if (inChapterIntro) {
        settings = part;
      }
    }

    if (part && !inChapterIntro) {
      inCode.active ? inCode.parts.push(part) : section.parts.push(part);
    }
  }

  return {
    title: storyName ?? "",
    description: storyDescription,
    markdown: markdown,
    sections,
    images: findImages(sections),
    state: {},
    settings,
  };
}

export function findImages(sections: Section[]): Image[] {
  const images: Array<Image> = sections.flatMap((section) => {
    const imageParts = section.parts.filter(
      (part) => part.type === "image"
    ) as Array<Image>;

    return imageParts;
  });

  return images;
}

export function renderMarkdown(markdown: string): string {
  return md.render(markdown);
}

export function storyToMarkdown(story: Story): string {
  const mermaid = storyToMermaid(story);
  const intro = introToMarkdown(story);
  const sections = story.sections
    .map((section) => sectionToMarkdown(section))
    .join("\n");
  return `${intro}\n\n${sections}\n\n${mermaidComment}\n\`\`\`mermaid\n${mermaid}\n\`\`\``;
}

export function introToMarkdown(story: Story): string {
  const settings = actionToMarkdown(story.settings);
  const description = story.description ? `${story.description}` : "";
  return `# ${story.title}\n\n${description}${settings}`;
}

export function sectionToMarkdown(section: Section): string {
  let ret = "";
  const visibleHeading = section.parts.find((p) => p.type === "header");
  const headerSize = visibleHeading ? "##" : "###";
  ret = ret + `${headerSize} ${section.heading} <!--- #${section.id} -->\n\n`;
  ret = ret + partsToMarkdown(section.parts);

  return ret;
}

export function partsToMarkdown(parts: Part[]): string {
  return parts
    .map((part) => {
      switch (part.type) {
        case "paragraph":
          return `${part.text}\n\n`;
        case "comment":
          return `<!--- ${part.text} -->\n\n`;
        case "image": {
          const description = part.description
            ? `<!--- ${part.description} -->\n`
            : "";
          return `${description}![${part.text}](${part.url})\n\n`;
        }
        case "choice":
          return `- [${part.text}](${part.target})\n`;
        case "condition":
          return conditionToMarkdown(part) + "\n\n";
        case "navigation":
          return `\`->[${part.text}](${part.target})\`\n\n`;
        case "action": {
          return actionToMarkdown(part) + "\n\n";
        }
      }
    })
    .join("");
}

function actionToMarkdown(action: Action): string {
  console.log("actionToMarkdown", action);
  return (
    "```json\n" +
    (action.markdown
      ? action.markdown + action.error
      : JSON.stringify(action.state, undefined, 2)) +
    "\n```"
  );
}

function conditionToMarkdown(code: Condition): string {
  let ret = "";
  ret = ret + "`" + code.condition + " {`\n\n";
  if (code.true) {
    ret = `${ret}${partsToMarkdown(code.true)}\n`;
  }
  if (code.false) {
    ret = ret + "`}:{`\n\n" + partsToMarkdown(code.false);
  }
  return ret + "`}`";
}

export function storyToMermaid(story: Story): string {
  let ret = "flowchart TD\n";
  for (const section of story.sections) {
    const hasAction = section.parts.find((part) => part.type === "action");
    const icon = hasAction ? " ‚≠ê" : "";

    ret = `${ret}    ${section.id}["${section.heading}${icon}"]\n`;
    ret = `${ret}    click ${section.id} "#${section.id}"\n`;
    for (const part of section.parts) {
      if (part.type === "choice") {
        const target = part.target.replace(/^#/, "");
        ret = `${ret}    ${section.id} -->|"${part.text}"| ${target}\n`;
      }
      if (part.type === "condition") {
        const navigationPart = part.true?.find((part) =>
          ["navigation", "choice"].includes(part.type)
        ) as Navigation | Choice | undefined;
        if (navigationPart) {
          const target = navigationPart.target.replace(/^#/, "");
          ret = `${ret}    ${section.id} -.->|"${part.condition}"| ${target}\n`;
        }
      }
    }
  }
  return ret;
}
